---
phase: 08-web-brief-preview-zoning
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/features/clients/components/WebBriefView.tsx
  - src/features/clients/components/WebBriefDocumentContent.tsx
  - src/app/api/web-section-rewrite/route.ts
autonomous: true
requirements:
  - WBPZ-08
  - WBPZ-09
  - WBPZ-10

must_haves:
  truths:
    - "Section edit form shows all content keys present in the section (not just title/subtitle/text)"
    - "A single AI button replaces the separate Yam and Rewrite buttons"
    - "Empty AI prompt applies Yam creative direction; non-empty prompt applies custom rewrite"
    - "AI rewrite agent receives brand platform, copywriter text, and report content alongside the section"
    - "Manual save via Sauvegarder button and Enter key (on input fields, not textareas)"
  artifacts:
    - path: "src/features/clients/components/WebBriefView.tsx"
      provides: "Dynamic section edit form with field introspection and merged AI button"
      contains: "inferFieldType"
    - path: "src/app/api/web-section-rewrite/route.ts"
      provides: "Rewrite API that accepts and uses strategy context"
      contains: "brandPlatform"
  key_links:
    - from: "src/features/clients/components/WebBriefView.tsx"
      to: "section.content"
      via: "Object.entries(content) introspection for dynamic form"
      pattern: "Object.entries.*content"
    - from: "src/features/clients/components/WebBriefDocumentContent.tsx"
      to: "src/app/api/web-section-rewrite/route.ts"
      via: "fetch with brandPlatform + copywriterText + reportContent in body"
      pattern: "brandPlatform|copywriterText|reportContent"
    - from: "src/features/clients/components/WebBriefDocumentContent.tsx"
      to: "src/lib/extract-strategy-context.ts"
      via: "getStrategyContext() already exists, now passed to rewrite API"
      pattern: "getStrategyContext"
---

<objective>
Replace hardcoded section edit fields with a dynamic form that adapts to content keys, merge the two AI buttons into one, and wire strategy context into the rewrite API.

Purpose: The current edit form only handles title/subtitle/text fields, ignoring any other content keys the AI may produce (headline, features, items, etc.). Users need to edit all content. The dual AI buttons confuse users; a single button with optional prompt is cleaner. The rewrite agent must read project strategy context for quality output.

Output: Dynamic section edit form, single AI button with inline prompt, rewrite API enhanced with strategy context.
</objective>

<execution_context>
@/Users/jeremyhervo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jeremyhervo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-web-brief-preview-zoning/08-RESEARCH.md
@.planning/phases/08-web-brief-preview-zoning/08-01-SUMMARY.md

@src/features/clients/components/WebBriefView.tsx
@src/features/clients/components/WebBriefDocumentContent.tsx
@src/app/api/web-section-rewrite/route.ts
@src/lib/extract-strategy-context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dynamic section edit form with field introspection</name>
  <files>
    src/features/clients/components/WebBriefView.tsx
  </files>
  <action>
1. In `WebBriefView.tsx`, replace the current hardcoded `SectionEditFormFields` (which only handles title/subtitle/text/items/cta_primary/cta_secondary/quotes) with a dynamic form system.

2. Create a `inferFieldType(value: unknown): FieldType` function inside the file (or extract to a small utility):
   - `typeof value === 'string' && value.length > 80` -> `'text'` (textarea)
   - `typeof value === 'string'` -> `'string'` (input)
   - `Array.isArray(value) && value.length > 0 && typeof value[0] === 'string'` -> `'array-strings'`
   - `Array.isArray(value)` -> `'array-objects'`
   - `typeof value === 'object' && value !== null` -> `'object'` (for CTA-like objects with label/url)
   - else -> `'unknown'` (skip rendering)

3. Create a `DynamicSectionFields` component that:
   - Takes `content: Record<string, unknown>` and `onPatch: (key: string, value: unknown) => void`.
   - Iterates `Object.entries(content)` and renders:
     - `'string'`: `<input type="text">` with label = humanized key name (e.g., "cta_primary" -> "Cta primary").
     - `'text'`: `<textarea rows={3}>` with label.
     - `'object'` where value has `label` and `url` keys: two inputs (label + url) side by side.
     - `'array-strings'`: list of inputs with add/remove buttons.
     - `'array-objects'`: for each item in array, render sub-fields recursively (one level deep). Show add/remove item buttons.
     - `'unknown'`: skip (don't render).
   - **Preserve the StableField pattern** already in the codebase: use `useRef` for local input state and only call `onPatch` on blur or explicit save — NOT on every keystroke. This prevents cursor jump issues.
   - Label keys are humanized: replace underscores with spaces, capitalize first letter.

4. Replace the existing form rendering in `PreviewSectionWithEdit` (the inline edit panel) with `DynamicSectionFields`.

5. Add save mechanism:
   - A "Sauvegarder" button that calls the parent's `onSectionContentChange` with accumulated patches.
   - Enter key handler: only fires save when focus is on an `<input type="text">`, NOT on `<textarea>` (where Enter creates newlines).
   - Use `onKeyDown` on the form container, check `e.target` tagName.

6. Keep the existing section header info (role badge, intent text) above the form fields.
  </action>
  <verify>
    - `npx tsc --noEmit` passes.
    - Open a web-brief section with diverse content keys (title, text, items, cta_primary, features, etc.): all fields appear in the edit form.
    - Edit a field and click Sauvegarder: changes persist.
    - Press Enter in an input field: saves. Press Enter in a textarea: creates newline (does not save).
    - No cursor jump issues during typing.
  </verify>
  <done>
    - Section edit form dynamically adapts to all content keys present in the section.
    - All field types (string, text, array, object/CTA) render appropriate controls.
    - Save works via button and Enter shortcut (inputs only).
    - StableField pattern preserved — no cursor jumps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Merge AI buttons into single button + wire strategy context to rewrite API</name>
  <files>
    src/features/clients/components/WebBriefView.tsx
    src/features/clients/components/WebBriefDocumentContent.tsx
    src/app/api/web-section-rewrite/route.ts
  </files>
  <action>
1. In `WebBriefView.tsx`, replace the two AI buttons (Yam + Rewrite) with a single merged button:
   - Replace `onSectionRewrite` and `onSectionYam` props with a single `onAiRewrite?: (sectionId: string, customPrompt?: string) => Promise<void>`.
   - Same for page sections: replace `onPageSectionRewrite` and `onPageSectionYam` with `onPageAiRewrite?: (pageSlug: string, sectionId: string, customPrompt?: string) => Promise<void>`.
   - In `PreviewSectionWithEdit`, replace the two buttons with:
     - A single button labeled "IA ◆" styled with `var(--accent-magenta)` (existing style).
     - Clicking the button toggles an inline prompt area (small textarea with placeholder "Laisser vide = touche Yam").
     - A "Generer" submit button next to the textarea.
     - On submit: if textarea is empty, call `onAiRewrite(sectionId)` (no customPrompt = Yam). If textarea has content, call `onAiRewrite(sectionId, promptValue)`.
   - Remove the separate `promptForSectionId` / `promptValue` state in favor of a per-section expanded state (use `aiPromptForSectionId: string | null`).

2. In `WebBriefDocumentContent.tsx`:
   - Merge `handleSectionRewrite` and `handleSectionYam` into a single `handleAiRewrite(sectionId: string, customPrompt?: string)`:
     - If `customPrompt` is undefined or empty: use `YAM_PROMPT` as the prompt.
     - Otherwise: use the custom prompt.
     - **Add strategy context to the API call body:**
       ```
       const ctx = getStrategyContext();
       body: JSON.stringify({
         section: { role, intent, content },
         customPrompt: effectivePrompt,
         architecture: data.architecture,
         brandPlatform: ctx.brandPlatform,
         copywriterText: ctx.copywriterText,
         reportContent: ctx.reportContent,
       })
       ```
   - Same merge for page section handlers.
   - Remove the old `handleSectionYam`, `handlePageSectionYam` functions.
   - Pass the merged callbacks to `WebBriefView` instead of separate ones.

3. Update `src/app/api/web-section-rewrite/route.ts`:
   - Accept `brandPlatform`, `copywriterText`, `reportContent` from the request body.
   - Update the SYSTEM_PROMPT to mention: "Tu reçois aussi le contexte stratégique du projet (plateforme de marque, texte copywriter, rapport de briefing). Utilise-le pour aligner le ton, la promesse, et les valeurs."
   - Add strategy context to the user content string sent to the AI:
     ```
     ## Contexte stratégique
     ${brandPlatform ? `Plateforme de marque: ${JSON.stringify(brandPlatform)}` : ''}
     ${copywriterText ? `Texte copywriter: ${copywriterText.substring(0, 2000)}` : ''}
     ${reportContent ? `Rapport: ${reportContent.substring(0, 2000)}` : ''}
     ```
   - Truncate strategy context to prevent exceeding token limits (2000 chars each max).
  </action>
  <verify>
    - `npx tsc --noEmit` passes.
    - `npm run build` succeeds.
    - Only one AI button ("IA ◆") appears per section in edit mode (no separate Yam or Rewrite buttons).
    - Clicking the button opens an inline prompt textarea.
    - Submitting with empty textarea applies Yam creative direction.
    - Submitting with a custom prompt applies custom rewrite.
    - Check the network request to `/api/web-section-rewrite`: body includes `brandPlatform`, `copywriterText`, `reportContent`.
    - Rewrite result updates the correct section (by id, not index).
  </verify>
  <done>
    - Single "IA ◆" button replaces separate Yam and Rewrite buttons.
    - Empty prompt = Yam direction, custom prompt = custom rewrite.
    - Strategy context (brand platform, copywriter text, report) is sent to the rewrite API.
    - Rewrite API uses strategy context in its system prompt for better output quality.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero type errors
2. `npm run build` — successful build
3. Open a section with diverse content keys: dynamic form shows all fields with appropriate controls
4. Edit fields and save: changes persist correctly
5. Only one AI button per section in edit mode
6. AI rewrite with empty prompt: applies Yam creative direction
7. AI rewrite with custom prompt: applies custom rewrite
8. Network inspector: rewrite API receives strategy context (brandPlatform, copywriterText, reportContent)
</verification>

<success_criteria>
- Edit form dynamically adapts to all content keys in any section.
- Single AI button replaces the dual Yam/Rewrite buttons.
- Strategy context is always sent to the rewrite API for context-aware output.
- All edits (manual and AI) target the correct section by UUID.
</success_criteria>

<output>
After completion, create `.planning/phases/08-web-brief-preview-zoning/08-03-SUMMARY.md`
</output>
