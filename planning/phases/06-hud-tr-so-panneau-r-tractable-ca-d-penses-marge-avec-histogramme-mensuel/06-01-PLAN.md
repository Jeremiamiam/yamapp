---
phase: 06-compta
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/store.ts
  - src/features/compta/components/YearSelector.tsx
  - src/features/compta/components/ComptaView.tsx
  - src/features/compta/components/index.ts
autonomous: true

must_haves:
  truths:
    - "User sees year selector with arrows showing current year by default"
    - "User can navigate between years (2020 to current+2)"
    - "KPIs reflect only deliverables from selected year"
    - "Rentrées = sum of prixFacturé for completed deliverables of selected year"
    - "Potentiel = sum of prixFacturé for pending/in-progress deliverables of selected year"
    - "Marge = Rentrées - sum of coutSousTraitance for completed deliverables"
  artifacts:
    - path: "src/lib/store.ts"
      provides: "comptaYear state + setComptaYear action"
      contains: "comptaYear"
    - path: "src/features/compta/components/YearSelector.tsx"
      provides: "Year navigation component with arrows"
      exports: ["YearSelector"]
    - path: "src/features/compta/components/ComptaView.tsx"
      provides: "Rewritten ComptaView with year-filtered KPIs and data"
      contains: "comptaYear"
  key_links:
    - from: "src/features/compta/components/YearSelector.tsx"
      to: "src/lib/store.ts"
      via: "useAppStore comptaYear/setComptaYear"
      pattern: "useAppStore.*comptaYear"
    - from: "src/features/compta/components/ComptaView.tsx"
      to: "src/lib/store.ts"
      via: "useAppStore comptaYear + deliverables"
      pattern: "comptaYear.*deliverables|deliverables.*comptaYear"
---

<objective>
Add year-based filtering to ComptaView with a year selector, and rewrite the KPI calculation logic to use deliverable status (completed = rentrées, pending/in-progress = potentiel) filtered by the selected year's dueDate.

Purpose: Foundation for the entire Phase 6 -- all downstream features (client tables, histogram) depend on year-filtered data and status-based categorization.
Output: Working ComptaView with year selector and accurate KPIs based on real deliverable data.
</objective>

<execution_context>
@/Users/jeremyhervo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jeremyhervo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@planning/PROJECT.md
@planning/ROADMAP.md
@planning/STATE.md
@planning/phases/06-hud-tr-so-panneau-r-tractable-ca-d-penses-marge-avec-histogramme-mensuel/06-CONTEXT.md
@planning/phases/06-hud-tr-so-panneau-r-tractable-ca-d-penses-marge-avec-histogramme-mensuel/06-RESEARCH.md

# Key source files to read before implementing
@src/lib/store.ts
@src/features/compta/components/ComptaView.tsx
@src/types/index.ts
@src/components/layout/Header.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add comptaYear state to Zustand store</name>
  <files>src/lib/store.ts</files>
  <action>
Add two new fields to the AppState interface and store implementation:

1. `comptaYear: number` -- default to `new Date().getFullYear()`
2. `setComptaYear: (year: number) => void` -- sets the year

In the AppState interface, add after the `timelineRange` block:
```
comptaYear: number;
setComptaYear: (year: number) => void;
```

In the store implementation (create callback), add:
```
comptaYear: new Date().getFullYear(),
setComptaYear: (year) => set({ comptaYear: year }),
```

This is a minimal addition. Do NOT add computed selectors to the store -- derivations will use useMemo in components (per research guidance: "don't store derived data in Zustand").
  </action>
  <verify>Run `npx tsc --noEmit` from the project root. No type errors related to comptaYear or setComptaYear.</verify>
  <done>Store has comptaYear (number, defaults to current year) and setComptaYear action. No type errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create YearSelector component</name>
  <files>src/features/compta/components/YearSelector.tsx, src/features/compta/components/index.ts</files>
  <action>
Create `src/features/compta/components/YearSelector.tsx`:

A simple controlled component with left/right chevron arrows and the current year displayed between them. Follow the exact pattern from 06-RESEARCH.md "Pattern 2: Year Selector UI Component".

Requirements (per locked decisions):
- Display format: `< 2026 >` with arrow buttons
- Default: current year (from store comptaYear)
- Min year: 2020, Max year: current year + 2
- Disabled state on arrows when at bounds
- Use existing CSS variables (--bg-secondary, --bg-tertiary, --text-primary, --text-muted)
- Inline SVG chevrons (like existing icon patterns in Header.tsx) -- do NOT import from external icon library

Specific implementation:
- `'use client';` directive at top
- Import `useAppStore` from `@/lib/store`
- Define `ChevronLeft` and `ChevronRight` as inline SVG components (16x16, stroke currentColor)
- Export named function `YearSelector`
- Wrap in a flex container with gap-3, bg-[var(--bg-secondary)] rounded-lg p-2
- Left button: onClick decrements year, disabled if comptaYear <= 2020
- Year display: text-xl font-bold, min-w-[4rem] text-center
- Right button: onClick increments year, disabled if comptaYear >= currentYear + 2
- Both buttons: aria-label in French ("Annee precedente" / "Annee suivante")

Update `src/features/compta/components/index.ts` to also export YearSelector:
```
export { ComptaView } from './ComptaView';
export { YearSelector } from './YearSelector';
```
  </action>
  <verify>Run `npx tsc --noEmit`. No type errors. Verify the file exists and exports YearSelector.</verify>
  <done>YearSelector.tsx exists, exports named YearSelector component, reads/writes comptaYear from store, has left/right arrow navigation with disabled bounds.</done>
</task>

<task type="auto">
  <name>Task 3: Rewrite ComptaView with year filtering and status-based KPIs</name>
  <files>src/features/compta/components/ComptaView.tsx</files>
  <action>
Rewrite ComptaView.tsx to implement year-based filtering and the correct business logic per user decisions.

**CRITICAL BUSINESS LOGIC (locked decisions):**
- Rentrées validées = deliverables where `status === 'completed'` AND `dueDate` is in `comptaYear`. Amount = `prixFacturé`.
- CA potentiel = deliverables where `status === 'pending' || status === 'in-progress'` AND `dueDate` is in `comptaYear`. Amount = `prixFacturé`. Includes both prospects and existing clients.
- Marge nette = Rentrées - sum(coutSousTraitance) of completed deliverables of that year.
- NO `isPotentiel` flag usage -- use deliverable `status` field instead.
- Backlog items (no dueDate) are excluded from year totals (cannot attribute to year).

**Changes to make:**

1. Add import of YearSelector:
```
import { YearSelector } from './YearSelector';
```

2. Get `comptaYear` from store (add to destructured useAppStore call):
```
const { deliverables, getClientById, comptaYear } = useAppStore();
```

3. Remove `comptaMonthly` from store destructuring (will be replaced in Plan 02).

4. Replace the `deliverablesReel` memo with year-filtered deliverables:
```typescript
const yearDeliverables = useMemo(() => {
  return deliverables.filter(d => {
    if (!d.dueDate) return false;
    return new Date(d.dueDate).getFullYear() === comptaYear;
  });
}, [deliverables, comptaYear]);
```

5. Replace KPI calculations with status-based logic:
```typescript
const completedDeliverables = useMemo(() =>
  yearDeliverables.filter(d => d.status === 'completed'),
  [yearDeliverables]
);

const potentielDeliverables = useMemo(() =>
  yearDeliverables.filter(d => d.status === 'pending' || d.status === 'in-progress'),
  [yearDeliverables]
);

const { totalFacturé, totalDépensé, margeNette } = useMemo(() => {
  let facturé = 0;
  let dépensé = 0;
  for (const d of completedDeliverables) {
    facturé += d.prixFacturé ?? 0;
    dépensé += d.coutSousTraitance ?? 0;
  }
  return { totalFacturé: facturé, totalDépensé: dépensé, margeNette: facturé - dépensé };
}, [completedDeliverables]);

const totalPotentiel = useMemo(() => {
  return potentielDeliverables.reduce((sum, d) => sum + (d.prixFacturé ?? 0), 0);
}, [potentielDeliverables]);
```

6. Replace `byClient` memo to use `completedDeliverables` (rentrées) instead of `deliverablesReel`:
```typescript
const byClientCompleted = useMemo(() => {
  const map = new Map<string, ClientCompta>();
  for (const d of completedDeliverables) {
    if (!d.clientId) continue;
    const existing = map.get(d.clientId);
    const client = getClientById(d.clientId);
    const prix = d.prixFacturé ?? 0;
    const sousTraitance = d.coutSousTraitance ?? 0;
    if (existing) {
      existing.totalFacturé += prix;
      existing.totalSousTraitance += sousTraitance;
      existing.marge = existing.totalFacturé - existing.totalSousTraitance;
      existing.deliverables.push(d);
    } else {
      map.set(d.clientId, {
        clientId: d.clientId,
        clientName: client?.name ?? 'Sans nom',
        totalFacturé: prix,
        totalSousTraitance: sousTraitance,
        marge: prix - sousTraitance,
        deliverables: [d],
      });
    }
  }
  return Array.from(map.values()).sort((a, b) => b.totalFacturé - a.totalFacturé);
}, [completedDeliverables, getClientById]);
```

7. Add a `byClientPotentiel` memo for potentiel section grouped by client:
```typescript
const byClientPotentiel = useMemo(() => {
  const map = new Map<string, { clientId: string; clientName: string; isProspect: boolean; total: number; deliverables: Deliverable[] }>();
  for (const d of potentielDeliverables) {
    if (!d.clientId) continue;
    const client = getClientById(d.clientId);
    const existing = map.get(d.clientId);
    const prix = d.prixFacturé ?? 0;
    if (existing) {
      existing.total += prix;
      existing.deliverables.push(d);
    } else {
      map.set(d.clientId, {
        clientId: d.clientId,
        clientName: client?.name ?? 'Sans nom',
        isProspect: client?.status === 'prospect',
        total: prix,
        deliverables: [d],
      });
    }
  }
  return Array.from(map.values()).sort((a, b) => b.total - a.total);
}, [potentielDeliverables, getClientById]);
```

8. In the JSX, add YearSelector at the top of the content, right after the subtitle paragraph:
```tsx
<div className="flex items-center justify-between">
  <p className="text-sm text-[var(--text-muted)] uppercase tracking-wider">
    Bilan annuel
  </p>
  <YearSelector />
</div>
```

9. Keep the 4 KPI cards layout (grid-cols-4) but update labels:
   - Card 1: "Rentrées validées" (green, totalFacturé) -- subtitle: "deliverables terminés {comptaYear}"
   - Card 2: "Sous-traitance" (red, totalDépensé) -- subtitle: "freelances + impression"
   - Card 3: "Marge nette" (blue, margeNette) -- subtitle: "rentrées - sous-traitance"
   - Card 4: "Potentiel" (amber/dashed, totalPotentiel) -- subtitle: "en cours + a venir {comptaYear}"

10. Replace the "Detail potentiel" section with `byClientPotentiel` grouped list. Each client row shows:
   - Client name + "(P)" badge if prospect (amber border pill)
   - Total amount
   - Expandable detail showing individual deliverables
   Use a separate `expandedPotentielId` state for this section.

11. Replace existing "Detail par client" table to use `byClientCompleted` and label it "Rentrées par client".

12. TEMPORARILY remove the histogram section (will be reimplemented in Plan 02). Replace with a placeholder comment:
```tsx
{/* Histogramme mensuel -- Plan 06-02 */}
```

13. Remove the `maxAbs` and `comptaMonthly`-related code entirely (the old mock histogram).

14. Remove the `livrablesPotentiel` memo (replaced by byClientPotentiel).

Keep all existing patterns: formatEur helper, ChevronDown component, admin/role checks, openDeliverableModal usage. Do NOT change the admin gate or loading states.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors.
Run `npm run build` or `npx next build` -- build succeeds.
Visually: navigate to Comptabilite tab, verify year selector shows current year with arrows, KPI cards display values, client tables show data grouped by client.
  </verify>
  <done>
ComptaView filters deliverables by selected year's dueDate. KPIs use status-based logic (completed=rentrées, pending/in-progress=potentiel). Year selector navigates between years. Client detail tables split into "Rentrées par client" (completed) and "Potentiel par client" (pending/in-progress with prospect indicator). No mock data dependencies.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` succeeds
3. ComptaView shows year selector defaulting to current year
4. Clicking year arrows changes displayed year and KPI values update
5. "Rentrées validées" KPI matches sum of prixFacturé for completed deliverables of selected year
6. "Potentiel" KPI matches sum of prixFacturé for pending/in-progress deliverables of selected year
7. "Marge nette" = Rentrées - Sous-traitance
8. Client tables show correct groupings with expandable rows
9. Prospect clients show "(P)" indicator in potentiel section
</verification>

<success_criteria>
- Year selector with arrows `< YYYY >` visible at top of ComptaView
- All KPIs filtered by selected year (dueDate-based)
- Business logic matches locked decisions exactly: completed=rentrées, pending|in-progress=potentiel
- No isPotentiel flag usage in filtering logic
- No mock comptaMonthly dependency
- Two client detail sections: "Rentrées par client" + "Potentiel par client"
- Prospect indicator visible on potentiel client rows
- TypeScript compiles, build passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-hud-tr-so-panneau-r-tractable-ca-d-penses-marge-avec-histogramme-mensuel/06-01-SUMMARY.md`
</output>
