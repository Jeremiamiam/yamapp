---
phase: 09-retroplanning-ia
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - supabase/migrations/20260222200000_create_retroplanning.sql
  - src/lib/store/types.ts
  - src/lib/store/slices/data.slice.ts
  - src/app/api/retroplanning/route.ts
  - src/lib/retroplanning-utils.ts
autonomous: true
requirements:
  - RETRO-01
  - RETRO-02
  - RETRO-03
  - RETRO-04
  - RETRO-05

must_haves:
  truths:
    - "L'IA peut recevoir le contenu d'un brief + deadline et retourner un JSON de taches structurees"
    - "Les dates de debut/fin sont calculees en arriere depuis la deadline (retroplanning)"
    - "Le retroplanning est persistable en base via Supabase upsert"
    - "Le store Zustand expose les actions CRUD pour retroplanning"
  artifacts:
    - path: "src/types/index.ts"
      provides: "RetroplanningTask, RetroplanningPlan, RetroplanningTaskColor types"
      contains: "RetroplanningTask"
    - path: "supabase/migrations/20260222200000_create_retroplanning.sql"
      provides: "retroplanning table with JSONB tasks, RLS policies"
      contains: "CREATE TABLE"
    - path: "src/app/api/retroplanning/route.ts"
      provides: "POST endpoint for AI retroplanning generation"
      exports: ["POST"]
    - path: "src/lib/retroplanning-utils.ts"
      provides: "computeDatesFromDeadline algorithm"
      exports: ["computeDatesFromDeadline"]
    - path: "src/lib/store/slices/data.slice.ts"
      provides: "loadRetroplanning, saveRetroplanning, deleteRetroplanning actions"
      contains: "retroplanning"
  key_links:
    - from: "src/app/api/retroplanning/route.ts"
      to: "Anthropic SDK"
      via: "client.messages.create"
      pattern: "anthropic.*messages\\.create"
    - from: "src/app/api/retroplanning/route.ts"
      to: "src/lib/retroplanning-utils.ts"
      via: "computeDatesFromDeadline import"
      pattern: "computeDatesFromDeadline"
    - from: "src/lib/store/slices/data.slice.ts"
      to: "supabase.retroplanning"
      via: "supabase.from('retroplanning').upsert"
      pattern: "from\\('retroplanning'\\)"
---

<objective>
Build the entire data layer for retroplanning: TypeScript types, Supabase migration, Zustand store CRUD, AI generation endpoint, and date computation utility.

Purpose: Provides the complete backend/data foundation so Plan 02 can focus purely on UI components.
Output: Working API endpoint, store actions, and database table for retroplanning.
</objective>

<execution_context>
@/Users/jeremyhervo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jeremyhervo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-retroplanning-ia/09-RESEARCH.md

@src/types/index.ts
@src/lib/store/types.ts
@src/lib/store/slices/data.slice.ts
@src/app/api/web-section-rewrite/route.ts
@supabase/migrations/20260218140000_create_projects.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types + Supabase migration + date utility</name>
  <files>
    src/types/index.ts
    supabase/migrations/20260222200000_create_retroplanning.sql
    src/lib/retroplanning-utils.ts
  </files>
  <action>
**1. Add types in `src/types/index.ts`:**

Add at the end of the file:

```typescript
// Retroplanning
export type RetroplanningTaskColor = 'cyan' | 'lime' | 'violet' | 'coral' | 'amber' | 'magenta';

export interface RetroplanningTask {
  id: string;
  label: string;
  startDate: string;      // ISO YYYY-MM-DD (computed)
  endDate: string;        // ISO YYYY-MM-DD (computed)
  durationDays: number;
  color: RetroplanningTaskColor;
}

export interface RetroplanningPlan {
  id?: string;            // Supabase row id
  clientId: string;
  deadline: string;       // ISO YYYY-MM-DD
  tasks: RetroplanningTask[];
  generatedAt: string;    // ISO datetime
  updatedAt: string;      // ISO datetime
}
```

**2. Create Supabase migration `supabase/migrations/20260222200000_create_retroplanning.sql`:**

```sql
CREATE TABLE IF NOT EXISTS public.retroplanning (
  id text PRIMARY KEY DEFAULT gen_random_uuid()::text,
  client_id text NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  deadline date NOT NULL,
  tasks jsonb NOT NULL DEFAULT '[]',
  generated_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT retroplanning_client_unique UNIQUE (client_id)
);

ALTER TABLE public.retroplanning ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can read retroplanning"
  ON public.retroplanning FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can insert retroplanning"
  ON public.retroplanning FOR INSERT
  TO authenticated
  WITH CHECK (true);

CREATE POLICY "Authenticated users can update retroplanning"
  ON public.retroplanning FOR UPDATE
  TO authenticated
  USING (true);

CREATE POLICY "Authenticated users can delete retroplanning"
  ON public.retroplanning FOR DELETE
  TO authenticated
  USING (true);
```

Follow exactly the RLS pattern from `20260218140000_create_projects.sql`.

**3. Create `src/lib/retroplanning-utils.ts`:**

Implement `computeDatesFromDeadline(tasks, deadline)`:
- Input: array of `{ id, label, durationDays, color }` + deadline `Date`
- Algorithm: walk backward from deadline. Last task ends at deadline. Each task's endDate = previous task's startDate. Each task's startDate = endDate - durationDays (calendar days, simple subtraction).
- Use pure JS date arithmetic (no date-fns): `new Date(date.getTime() - durationDays * 86400000)`.
- Format dates as `YYYY-MM-DD` strings.
- Return `RetroplanningTask[]` with computed `startDate` and `endDate`.

Also export a helper `daysBetween(start: string, end: string): number` that returns the number of calendar days between two ISO date strings (used by Gantt component later).
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Verify the migration SQL is valid syntax. Verify `retroplanning-utils.ts` exports `computeDatesFromDeadline` and `daysBetween`.
  </verify>
  <done>
RetroplanningTask and RetroplanningPlan types exist. Migration file ready to apply. computeDatesFromDeadline correctly distributes tasks backward from deadline.
  </done>
</task>

<task type="auto">
  <name>Task 2: AI endpoint + Store CRUD actions</name>
  <files>
    src/app/api/retroplanning/route.ts
    src/lib/store/types.ts
    src/lib/store/slices/data.slice.ts
  </files>
  <action>
**1. Create `src/app/api/retroplanning/route.ts`:**

Follow exactly the pattern from `src/app/api/web-section-rewrite/route.ts`:

- Import `Anthropic` from `@anthropic-ai/sdk`, `jsonrepair` from `jsonrepair`.
- Create const `anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })`.
- **SYSTEM_PROMPT:** "Tu es un chef de projet senior dans une agence creative. Tu recois le contenu d'un brief client et une date de livraison finale. Tu generes un retroplanning : liste ordonnee d'etapes du debut du projet a la fin. Tu adaptes les etapes au type de projet (site web, identite visuelle, video, campagne...). Aucun template fixe : tu lis le brief et deduis ce qui est necessaire."
  - Output format: `<structured_output>` containing JSON array of `{ id: "uuid", label: "...", durationDays: N, color: "cyan|lime|violet|coral|amber|magenta" }`.
  - Tasks ordered from project start (index 0) to end.
  - Between 4 and 10 tasks max.
  - `durationDays` = estimated working days.
  - The AI must NOT output absolute dates — only `durationDays`.

- **POST handler:**
  - Validate `ANTHROPIC_API_KEY`.
  - Parse body: `{ briefContent: string, deadline: string, clientName: string }`.
  - Validate: briefContent and deadline required.
  - Build user content: include clientName, deadline, and briefContent (truncated to 6000 chars max).
  - Call `anthropic.messages.create` with model `claude-sonnet-4-6`, max_tokens 2000, temperature 0.5.
  - Parse response: extract `<structured_output>` block, parse JSON array. Use `jsonrepair` as fallback (same pattern as `extractJsonFromResponse` in web-section-rewrite).
  - For each task in parsed array, generate a UUID with `crypto.randomUUID()` if the AI didn't provide one.
  - Import `computeDatesFromDeadline` from `@/lib/retroplanning-utils` and compute dates.
  - Return `{ tasks: RetroplanningTask[] }` (with computed dates).

**2. Extend store types in `src/lib/store/types.ts`:**

- Import `RetroplanningPlan` from `@/types`.
- Add to `AppState` interface:
  ```typescript
  // Retroplanning
  retroplanning: Map<string, RetroplanningPlan>;
  loadRetroplanning: (clientId: string) => Promise<void>;
  saveRetroplanning: (clientId: string, plan: RetroplanningPlan) => Promise<void>;
  deleteRetroplanning: (clientId: string) => Promise<void>;
  getRetroplanningByClientId: (clientId: string) => RetroplanningPlan | undefined;
  ```

**3. Implement store actions in `src/lib/store/slices/data.slice.ts`:**

- Initialize `retroplanning: new Map()` in the initial state.
- `loadRetroplanning(clientId)`: Query `supabase.from('retroplanning').select('*').eq('client_id', clientId).maybeSingle()`. If row exists, map `client_id` → `clientId`, `generated_at` → `generatedAt`, `updated_at` → `updatedAt`, parse `tasks` from JSONB. Set in the Map.
- `saveRetroplanning(clientId, plan)`: Upsert with `supabase.from('retroplanning').upsert({ client_id: clientId, deadline: plan.deadline, tasks: plan.tasks, updated_at: new Date().toISOString() }, { onConflict: 'client_id' })`. Update the Map.
- `deleteRetroplanning(clientId)`: Delete from Supabase where `client_id = clientId`. Remove from Map.
- `getRetroplanningByClientId(clientId)`: Return `get().retroplanning.get(clientId)`.

Follow existing Supabase patterns: use `createClient()` from `@/lib/supabase/client`, handle errors with console.error, use `set(state => ({ ... }))` for Map updates.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Run `curl -X POST http://localhost:3000/api/retroplanning -H 'Content-Type: application/json' -d '{"briefContent":"Site web vitrine 5 pages pour cabinet avocat","deadline":"2026-04-15","clientName":"Test"}' ` and verify JSON response with tasks array containing startDate/endDate fields.
  </verify>
  <done>
API endpoint returns structured tasks with computed dates. Store actions can load/save/delete retroplanning from Supabase. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (types, store, API all type-safe)
2. Migration SQL file has correct syntax and follows project RLS pattern
3. API endpoint responds with valid RetroplanningTask[] (dates computed backward from deadline)
4. Store can round-trip: saveRetroplanning → loadRetroplanning → data matches
5. computeDatesFromDeadline correctly places last task ending at deadline
</verification>

<success_criteria>
- RetroplanningTask and RetroplanningPlan types defined in src/types/index.ts
- Supabase migration creates retroplanning table with JSONB + RLS
- AI endpoint at /api/retroplanning generates tasks from brief content
- Date computation walks backward from deadline
- Store CRUD actions for retroplanning work with Supabase
- TypeScript compilation clean
</success_criteria>

<output>
After completion, create `.planning/phases/09-retroplanning-ia/09-01-SUMMARY.md`
</output>
