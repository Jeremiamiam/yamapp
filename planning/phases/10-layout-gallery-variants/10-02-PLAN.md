---
phase: 10-layout-gallery-variants
plan: 02
type: execute
wave: 2
depends_on:
  - 10-01
files_modified:
  - src/app/api/edit-layout/route.ts
  - src/app/api/read-layout/route.ts
  - src/features/layout-gallery/components/LayoutGallery.tsx
  - src/features/layout-gallery/components/LayoutCodeEditor.tsx
autonomous: true
requirements:
  - LGAL-07
  - LGAL-08
  - LGAL-09

must_haves:
  truths:
    - "User can view the TSX source code of any layout in the gallery"
    - "User can edit layout code manually in a textarea and save changes"
    - "User can provide an AI prompt to modify an existing layout and preview the result before saving"
    - "Read-layout API returns the TSX file content for a given role"
    - "Edit-layout API accepts existing code + prompt, returns modified code without writing to disk"
  artifacts:
    - path: "src/app/api/read-layout/route.ts"
      provides: "GET endpoint returning layout TSX file content"
      exports: ["GET"]
    - path: "src/app/api/edit-layout/route.ts"
      provides: "POST endpoint for AI-prompted layout code editing"
      exports: ["POST"]
    - path: "src/features/layout-gallery/components/LayoutCodeEditor.tsx"
      provides: "Code viewing/editing panel with manual + AI tabs"
      min_lines: 60
  key_links:
    - from: "src/features/layout-gallery/components/LayoutGallery.tsx"
      to: "/api/read-layout"
      via: "fetch GET when opening code editor"
      pattern: "fetch.*read-layout"
    - from: "src/features/layout-gallery/components/LayoutCodeEditor.tsx"
      to: "/api/edit-layout"
      via: "fetch POST for AI prompt editing"
      pattern: "fetch.*edit-layout"
    - from: "LayoutCodeEditor"
      to: "/api/generate-layout"
      via: "fetch POST to save confirmed code changes to disk"
      pattern: "fetch.*generate-layout"
---

<objective>
Add AI prompt editing and manual code editing capabilities to the Layout Gallery. Create two new API endpoints (read-layout, edit-layout) and a LayoutCodeEditor component that integrates into the gallery modal.

Purpose: Allow users to view, manually edit, and AI-edit layout TSX code directly from the gallery — completing the layout management workflow.

Output: read-layout API, edit-layout API, LayoutCodeEditor component, gallery integration.
</objective>

<execution_context>
@/Users/jeremyhervo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jeremyhervo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-layout-gallery-variants/10-RESEARCH.md
@.planning/phases/10-layout-gallery-variants/10-01-SUMMARY.md

# Key source files
@src/app/api/generate-layout/route.ts
@src/lib/section-registry.ts
@src/lib/custom-layouts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Read-layout and Edit-layout API endpoints</name>
  <files>
    src/app/api/read-layout/route.ts
    src/app/api/edit-layout/route.ts
  </files>
  <action>
**GET /api/read-layout (src/app/api/read-layout/route.ts):**
- Accept query parameter `role` (e.g., `?role=hero` or `?role=product_grid`)
- Convert role to PascalCase component name using same `toPascalCase` logic as generate-layout (copy the helper or extract shared)
- Build file path: `path.join(process.cwd(), 'src', 'components', 'layouts', 'Layout' + pascalName + '.tsx')`
- Read file with `fs.readFileSync(filePath, 'utf-8')`
- If file not found: return `{ error: 'Layout non trouvé' }` with status 404
- If found: return `{ role, code: fileContent, componentName }`
- Import `NextResponse` from `next/server`, `fs` and `path` from Node builtins

**POST /api/edit-layout (src/app/api/edit-layout/route.ts):**
- Accept JSON body: `{ role: string; existingCode: string; prompt: string }`
- Validate: role and prompt required, existingCode required
- Import Anthropic SDK: `import Anthropic from '@anthropic-ai/sdk'`
- Initialize client: `new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })`
- Build system prompt — reuse the SYSTEM_PROMPT from generate-layout with one addition: "Tu modifies un composant existant. Préserve le nom de l'export et l'interface. Ne change que ce qui est demandé par l'instruction."
- User message: `Modifie ce composant React selon l'instruction suivante.\n\nInstruction : "${prompt}"\n\nCode actuel :\n\`\`\`tsx\n${existingCode}\n\`\`\`\n\nRéponds uniquement avec le code TSX modifié complet.`
- Model: `'claude-sonnet-4-20250514'`, max_tokens: 4096
- Extract TSX from response using same `extractTsxFromResponse` pattern as generate-layout
- Return `{ code: extractedCode }` — does NOT write to disk
- On error: return `{ error: message }` with status 500

IMPORTANT: The edit-layout endpoint returns code only — saving to disk is handled by a subsequent call to the existing generate-layout endpoint (which has idempotence check). The read-layout endpoint is a simple fs.readFileSync wrapper. Use `import { NextRequest, NextResponse } from 'next/server'` for proper Next.js 16 API route typing.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors.
Both route files exist at their expected paths.
`curl http://localhost:3000/api/read-layout?role=hero` returns TSX code (requires dev server running).
  </verify>
  <done>
GET /api/read-layout returns layout TSX file content for any role. POST /api/edit-layout accepts code + prompt, returns AI-modified code without writing to disk. Both endpoints follow existing API route patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: LayoutCodeEditor component + gallery integration</name>
  <files>
    src/features/layout-gallery/components/LayoutCodeEditor.tsx
    src/features/layout-gallery/components/LayoutGallery.tsx
  </files>
  <action>
**LayoutCodeEditor.tsx:**
- Props: `{ role: string; onClose: () => void; onSaved?: () => void }`
- Two tabs: "Code" and "IA" — use local state `activeTab: 'code' | 'ai'`
- On mount: fetch layout code via `GET /api/read-layout?role=${role}` — store in `code` state
- Loading state: show spinner while fetching

**Code tab:**
- Render a `<textarea>` with monospace font (`font-mono text-xs`), full width, min-height 300px
- Value bound to `code` state, editable
- "Sauvegarder" button (accent-cyan): calls `POST /api/generate-layout` with `{ role, code }` — NOTE: the existing generate-layout checks `fs.existsSync` and skips AI generation if file exists, so we need a different approach. Instead, write a direct approach:
  - For custom layouts (not standard): call a helper that writes the code. The simplest approach: add a `code` field to the generate-layout POST body. If `code` is provided, skip AI generation and write this code directly to the file. Modify `generate-layout/route.ts` minimally: after the `if (fs.existsSync(filePath))` block, add `if (body.code) { fs.writeFileSync(filePath, body.code, 'utf-8'); updateCustomLayoutsFile(...); return NextResponse.json({ success: true, role, alreadyExisted: true }); }`.
- After save: call `onSaved?.()` which should trigger `router.refresh()` in the parent

**AI tab:**
- Render a prompt textarea (3 rows) with placeholder "Décrivez la modification souhaitée..."
- "Modifier via IA" button (accent-magenta): calls `POST /api/edit-layout` with `{ role, existingCode: code, prompt }`
- On response: update `code` state with the returned modified code (user can preview in the Code tab)
- Show loading state during AI call (spinner + "Modification en cours...")
- The user then reviews the code in the Code tab and clicks "Sauvegarder" to persist

**Layout:**
- Slide-in panel or overlay inside the gallery (not a separate modal)
- Header: role name + tabs + close button
- Body: tab content
- Footer: action buttons

**LayoutGallery.tsx modifications (from Plan 01):**
- Add "Éditer" button on each card (small pencil icon, appears on hover alongside "Créer variante")
- When clicked: set `editingRole` state → render `<LayoutCodeEditor role={editingRole} onClose={...} onSaved={...} />`
- On `onSaved`: call `router.refresh()` to pick up code changes

**generate-layout/route.ts modification:**
- After the idempotence check `if (fs.existsSync(filePath))`, add handling for direct code injection:
  ```typescript
  // Direct code write (from gallery editor)
  if (body.code && typeof body.code === 'string') {
    fs.writeFileSync(filePath, body.code, 'utf-8');
    updateCustomLayoutsFile(customLayoutsPath, componentName, `@/components/layouts/${componentName}`, role);
    return NextResponse.json({ success: true, role, componentPath: `src/components/layouts/${fileName}` });
  }
  ```
  Place this BEFORE the `if (fs.existsSync(filePath))` idempotence check so it always writes when `code` is provided.
- Update the body type: `const body = (await req.json()) as { role?: string; sampleContent?: Record<string, unknown>; code?: string };`

IMPORTANT: Standard layouts (those in SECTION_TO_LAYOUT) should be read-only in the code editor. Only custom layouts should have "Sauvegarder". Add a check: if `role` is in SECTION_TO_LAYOUT keys, show the code as read-only (textarea disabled) with a note "Layout standard — lecture seule". Use only CSS variables, Tailwind, French UI text.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors.
LayoutCodeEditor.tsx exists with both tab implementations.
generate-layout/route.ts accepts `code` body field.
  </verify>
  <done>
User can view any layout's TSX code in the gallery. Custom layouts can be edited manually (textarea + save) or via AI prompt (instruction → preview → save). Standard layouts are read-only. All changes persist to disk via generate-layout API.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. GET /api/read-layout?role=hero returns the LayoutHero.tsx content
4. POST /api/edit-layout with code + prompt returns modified code
5. LayoutCodeEditor renders with Code and AI tabs
6. Saving modified code in the editor persists to the layout file
7. Standard layouts show as read-only in the editor
8. Gallery "Éditer" button opens the code editor panel
</verification>

<success_criteria>
- Both API endpoints functional (read-layout, edit-layout)
- Code editor displays layout TSX, allows manual edit + save for custom layouts
- AI prompt editing returns modified code for preview before save
- Standard layouts are read-only in the editor
- Generate-layout API accepts direct `code` parameter for saving
- Zero TypeScript errors, build passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-layout-gallery-variants/10-02-SUMMARY.md`
</output>
