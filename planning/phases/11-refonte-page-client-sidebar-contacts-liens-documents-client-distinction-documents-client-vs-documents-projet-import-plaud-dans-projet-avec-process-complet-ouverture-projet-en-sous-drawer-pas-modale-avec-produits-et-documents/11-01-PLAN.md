---
phase: 11-refonte-page-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/
  - src/types/index.ts
  - src/lib/supabase-mappers.ts
  - src/lib/store/actions/clients.ts
  - src/features/clients/components/sections/DocumentsSection.tsx
autonomous: true
requirements: []

must_haves:
  truths:
    - "Documents table has optional project_id column (nullable FK to projects)"
    - "ClientDocument type has optional projectId field"
    - "Documents with projectId null = documents client (génériques)"
    - "Documents with projectId set = documents projet"
    - "DocumentsSection sidebar shows only client-scoped documents (projectId null)"
  artifacts:
    - path: "supabase/migrations/"
      provides: "Migration adding project_id to documents"
  key_links:
    - from: "documents"
      to: "projects"
      via: "project_id FK"
      pattern: "project_id"
---

<objective>
Ajouter la distinction documents client vs documents projet via une colonne project_id sur la table documents. Les documents sans project_id restent des documents génériques du client. Les documents avec project_id sont rattachés à un projet.

Output: migration Supabase, types ClientDocument.projectId, mappers, store CRUD pour project-scoped documents, DocumentsSection filtrée sur projectId null en sidebar.
</objective>

<execution_context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@planning/STATE.md
@docs/CREATIVE-PIPELINE.md
</execution_context>

<context>
# Key source files
@src/types/index.ts (ClientDocument)
@src/lib/supabase-mappers.ts (mapDocumentRow)
@src/lib/store/actions/clients.ts (addDocument, updateDocument)
@src/features/clients/components/sections/DocumentsSection.tsx
@supabase/migrations/00001_initial_schema.sql (documents table)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration project_id sur documents</name>
  <files>
    supabase/migrations/
  </files>
  <action>
Créer une migration Supabase :
- Fichier: `supabase/migrations/20260223000000_add_project_id_to_documents.sql`
- Contenu:
```sql
ALTER TABLE public.documents
  ADD COLUMN IF NOT EXISTS project_id text REFERENCES public.projects(id) ON DELETE SET NULL;

CREATE INDEX IF NOT EXISTS idx_documents_project_id ON public.documents(project_id);
```
- Appliquer via MCP Supabase apply_migration si possible, sinon documenter la commande.

Contrainte: project_id nullable — documents existants restent client-level (project_id = null).
  </action>
  <verify>
Migration file exists. Si MCP utilisé, confirmation apply_migration success.
  </verify>
  <done>
Migration créée et appliquée.
  </done>
</task>

<task type="auto">
  <name>Task 2: Types et mappers ClientDocument.projectId</name>
  <files>
    src/types/index.ts
    src/lib/supabase-mappers.ts
  </files>
  <action>
**types/index.ts** — ClientDocument:
- Ajouter `projectId?: string` (optionnel)

**supabase-mappers.ts** — DocumentRow et mapDocumentRow:
- DocumentRow: ajouter `project_id?: string | null`
- mapDocumentRow: mapper `project_id` → `projectId` (undefined si null)

**data.slice / loadData** — documents select:
- Inclure `project_id` dans le select de documents
  </action>
  <verify>
npx tsc --noEmit. ClientDocument.projectId utilisé correctement.
  </verify>
  <done>
Types et mappers à jour.
  </done>
</task>

<task type="auto">
  <name>Task 3: Store actions — addDocument avec projectId</name>
  <files>
    src/lib/store/actions/clients.ts
  </files>
  <action>
**clients.ts — addDocument**:
- Signature: `addDocument(clientId: string, data: { type, title, content, projectId?: string })`
- Insert Supabase: inclure `project_id: data.projectId ?? null`
- Mapper retour avec projectId

**clients.ts — updateDocument**:
- Permettre update de projectId si besoin (cas rare)

Vérifier que les appels existants à addDocument restent valides (projectId optionnel).
  </action>
  <verify>
addDocument(clientId, { type, title, content }) fonctionne sans projectId.
addDocument(clientId, { type, title, content, projectId: 'xxx' }) insère project_id.
  </verify>
  <done>
Store gère project-scoped documents.
  </done>
</task>

<task type="auto">
  <name>Task 4: DocumentsSection — filtrer documents client (sidebar)</name>
  <files>
    src/features/clients/components/sections/DocumentsSection.tsx
  </files>
  <action>
DocumentsSection reçoit déjà `clientId`. Les documents du client viennent de `client.documents`.

Modifier le filtrage des documents affichés :
- Ne montrer que les documents où `projectId == null` ou `!projectId` (documents génériques client)
- Exclure les documents avec projectId (ils seront affichés dans le ProjectDrawer du plan 11-03)

Si client.documents est un tableau flat, filtrer :
`const clientDocs = (client.documents || []).filter(d => !d.projectId);`
  </action>
  <verify>
Sidebar DocumentsSection n'affiche que les documents sans projectId.
  </verify>
  <done>
DocumentsSection affiche uniquement documents client.
  </done>
</task>

</tasks>

<verification>
1. Migration appliquée, project_id sur documents
2. ClientDocument.projectId dans types et mappers
3. addDocument supporte projectId optionnel
4. DocumentsSection sidebar = documents client only (projectId null)
5. npx tsc --noEmit pass
</verification>

<success_criteria>
- Documents peuvent être rattachés à un projet (project_id)
- Documents client (sans projet) affichés dans sidebar
- Rétrocompatibilité : documents existants inchangés
</success_criteria>

<output>
After completion, create planning/phases/11-.../11-01-SUMMARY.md
</output>
